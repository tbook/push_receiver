# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: mcs.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List

import betterproto


@dataclass
class ChromeBuildProto(betterproto.Message):
    """Build characteristics unique to the Chrome browser, and Chrome OS"""

    # The platform of the device.
    platform: "ChromeBuildProtoPlatform" = betterproto.enum_field(1)
    # The Chrome instance's version.
    chrome_version: str = betterproto.string_field(2)
    # The Channel (build type) of Chrome.
    channel: "ChromeBuildProtoChannel" = betterproto.enum_field(3)


@dataclass
class AndroidCheckinProto(betterproto.Message):
    """Information sent by the device in a "checkin" request."""

    # Miliseconds since the Unix epoch of the device's last successful checkin.
    last_checkin_msec: int = betterproto.int64_field(2)
    # The current MCC+MNC of the mobile device's current cell.
    cell_operator: str = betterproto.string_field(6)
    # The MCC+MNC of the SIM card (different from operator if the device is
    # roaming, for instance).
    sim_operator: str = betterproto.string_field(7)
    # The device's current roaming state (reported starting in eclair builds).
    # Currently one of "{,not}mobile-{,not}roaming", if it is present at all.
    roaming: str = betterproto.string_field(8)
    # For devices supporting multiple user profiles (which may be supported
    # starting in jellybean), the ordinal number of the profile that is checking
    # in.  This is 0 for the primary profile (which can't be changed without
    # wiping the device), and 1,2,3,... for additional profiles (which can be
    # added and deleted freely).
    user_number: int = betterproto.int32_field(9)
    # Class of device.  Indicates the type of build proto
    # (IosBuildProto/ChromeBuildProto/AndroidBuildProto) That is included in this
    # proto
    type: "DeviceType" = betterproto.enum_field(12)
    # For devices running MCS on Chrome, build-specific characteristics of the
    # browser.  There are no hardware aspects (except for ChromeOS). This will
    # only be populated for Chrome builds/ChromeOS devices
    chrome_build: "ChromeBuildProto" = betterproto.message_field(13)


@dataclass
class GservicesSetting(betterproto.Message):
    """A concrete name/value pair sent to the device's Gservices database."""

    name: bytes = betterproto.bytes_field(1)
    value: bytes = betterproto.bytes_field(2)


@dataclass
class AndroidCheckinRequest(betterproto.Message):
    """Devices send this every few hours to tell us how they're doing."""

    # IMEI (used by GSM phones) is sent and stored as 15 decimal digits; the 15th
    # is a check digit.
    imei: str = betterproto.string_field(1)
    # MEID (used by CDMA phones) is sent and stored as 14 hexadecimal digits (no
    # check digit).
    meid: str = betterproto.string_field(10)
    # MAC address (used by non-phone devices).  12 hexadecimal digits; no
    # separators (eg "0016E6513AC2", not "00:16:E6:51:3A:C2").
    mac_addr: List[str] = betterproto.string_field(9)
    # An array parallel to mac_addr, describing the type of interface. Currently
    # accepted values: "wifi", "ethernet", "bluetooth".  If not present, "wifi"
    # is assumed.
    mac_addr_type: List[str] = betterproto.string_field(19)
    # Serial number (a manufacturer-defined unique hardware identifier).
    # Alphanumeric, case-insensitive.
    serial_number: str = betterproto.string_field(16)
    # Older CDMA networks use an ESN (8 hex digits) instead of an MEID.
    esn: str = betterproto.string_field(17)
    id: int = betterproto.int64_field(2)
    logging_id: int = betterproto.int64_field(7)
    digest: str = betterproto.string_field(3)
    locale: str = betterproto.string_field(6)
    checkin: "AndroidCheckinProto" = betterproto.message_field(4)
    # DEPRECATED, see AndroidCheckinProto.requested_group
    desired_build: str = betterproto.string_field(5)
    # Blob of data from the Market app to be passed to Market API server
    market_checkin: str = betterproto.string_field(8)
    # SID cookies of any google accounts stored on the phone.  Not logged.
    account_cookie: List[str] = betterproto.string_field(11)
    # Time zone.  Not currently logged.
    time_zone: str = betterproto.string_field(12)
    # Security token used to validate the checkin request. Required for android
    # IDs issued to Froyo+ devices, not for legacy IDs.
    security_token: float = betterproto.fixed64_field(13)
    # Version of checkin protocol. There are currently two versions: - version
    # field missing: android IDs are assigned based on   hardware identifiers.
    # unsecured in the sense that you can   "unregister" someone's phone by
    # sending a registration request   with their IMEI/MEID/MAC. - version=2:
    # android IDs are assigned randomly.  The device is   sent a security token
    # that must be included in all future   checkins for that android id. -
    # version=3: same as version 2, but the 'fragment' field is   provided, and
    # the device understands incremental updates to the   gservices table (ie,
    # only returning the keys whose values have   changed.) (version=1 was
    # skipped to avoid confusion with the "missing" version field that is
    # effectively version 1.)
    version: int = betterproto.int32_field(14)
    # OTA certs accepted by device (base-64 SHA-1 of cert files).  Not logged.
    ota_cert: List[str] = betterproto.string_field(15)
    # A single CheckinTask on the device may lead to multiple checkin requests if
    # there is too much log data to upload in a single request.  For version 3
    # and up, this field will be filled in with the number of the request,
    # starting with 0.
    fragment: int = betterproto.int32_field(20)
    # For devices supporting multiple users, the name of the current profile
    # (they all check in independently, just as if they were multiple physical
    # devices).  This may not be set, even if the device is using multiuser.
    # (checkin.user_number should be set to the ordinal of the user.)
    user_name: str = betterproto.string_field(21)
    # For devices supporting multiple user profiles, the serial number for the
    # user checking in.  Not logged.  May not be set, even if the device
    # supportes multiuser.  checkin.user_number is the ordinal of the user (0, 1,
    # 2, ...), which may be reused if users are deleted and re-created.
    # user_serial_number is never reused (unless the device is wiped).
    user_serial_number: int = betterproto.int32_field(22)


@dataclass
class AndroidCheckinResponse(betterproto.Message):
    """The response to the device."""

    stats_ok: bool = betterproto.bool_field(1)
    time_msec: int = betterproto.int64_field(3)
    # Provisioning is sent if the request included an obsolete digest. For
    # version <= 2, 'digest' contains the digest that should be sent back to the
    # server on the next checkin, and 'setting' contains the entire gservices
    # table (which replaces the entire current table on the device). for version
    # >= 3, 'digest' will be absent.  If 'settings_diff' is false, then 'setting'
    # contains the entire table, as in version 2.  If 'settings_diff' is true,
    # then 'delete_setting' contains the keys to delete, and 'setting' contains
    # only keys to be added or for which the value has changed.  All other keys
    # in the current table should be left untouched.  If 'settings_diff' is
    # absent, don't touch the existing gservices table.
    digest: str = betterproto.string_field(4)
    settings_diff: bool = betterproto.bool_field(9)
    delete_setting: List[str] = betterproto.string_field(10)
    setting: List["GservicesSetting"] = betterproto.message_field(5)
    market_ok: bool = betterproto.bool_field(6)
    android_id: float = betterproto.fixed64_field(7)
    security_token: float = betterproto.fixed64_field(8)
    version_info: str = betterproto.string_field(11)


class DeviceType(betterproto.Enum):
    """
    enum values correspond to the type of device. Used in the
    AndroidCheckinProto and Device proto.
    """

    # Android Device
    DEVICE_ANDROID_OS = 1
    # Apple IOS device
    DEVICE_IOS_OS = 2
    # Chrome browser - Not Chrome OS.  No hardware records.
    DEVICE_CHROME_BROWSER = 3
    # Chrome OS
    DEVICE_CHROME_OS = 4


class ChromeBuildProtoPlatform(betterproto.Enum):
    PLATFORM_WIN = 1
    PLATFORM_MAC = 2
    PLATFORM_LINUX = 3
    PLATFORM_CROS = 4
    PLATFORM_IOS = 5
    PLATFORM_ANDROID = 6


class ChromeBuildProtoChannel(betterproto.Enum):
    CHANNEL_STABLE = 1
    CHANNEL_BETA = 2
    CHANNEL_DEV = 3
    CHANNEL_CANARY = 4
    CHANNEL_UNKNOWN = 5


class ClientEventType(betterproto.Enum):
    UNKNOWN = 0
    DISCARDED_EVENTS = 1
    FAILED_CONNECTION = 2
    SUCCESSFUL_CONNECTION = 3


class LoginRequestAuthService(betterproto.Enum):
    ANDROID_ID = 2


class IqStanzaIqType(betterproto.Enum):
    GET = 0
    SET = 1
    RESULT = 2
    IQ_ERROR = 3


@dataclass
class HeartbeatPing(betterproto.Message):
    """*TAG: 0"""

    stream_id: int = betterproto.int32_field(1)
    last_stream_id_received: int = betterproto.int32_field(2)
    status: int = betterproto.int64_field(3)


@dataclass
class HeartbeatAck(betterproto.Message):
    """*TAG: 1"""

    stream_id: int = betterproto.int32_field(1)
    last_stream_id_received: int = betterproto.int32_field(2)
    status: int = betterproto.int64_field(3)


@dataclass
class ErrorInfo(betterproto.Message):
    code: int = betterproto.int32_field(1)
    message: str = betterproto.string_field(2)
    type: str = betterproto.string_field(3)
    extension: "Extension" = betterproto.message_field(4)


@dataclass
class Setting(betterproto.Message):
    name: str = betterproto.string_field(1)
    value: str = betterproto.string_field(2)


@dataclass
class HeartbeatStat(betterproto.Message):
    ip: str = betterproto.string_field(1)
    timeout: bool = betterproto.bool_field(2)
    interval_ms: int = betterproto.int32_field(3)


@dataclass
class HeartbeatConfig(betterproto.Message):
    upload_stat: bool = betterproto.bool_field(1)
    ip: str = betterproto.string_field(2)
    interval_ms: int = betterproto.int32_field(3)


@dataclass
class ClientEvent(betterproto.Message):
    """
    ClientEvents are used to inform the server of failed and successful
    connections.
    """

    # Common fields [1-99]
    type: "ClientEventType" = betterproto.enum_field(1)
    # Fields for DISCARDED_EVENTS messages [100-199]
    number_discarded_events: int = betterproto.uint32_field(100)
    # Fields for FAILED_CONNECTION and SUCCESSFUL_CONNECTION messages [200-299]
    # Network type is a value in net::NetworkChangeNotifier::ConnectionType.
    network_type: int = betterproto.int32_field(200)
    time_connection_started_ms: int = betterproto.uint64_field(202)
    time_connection_ended_ms: int = betterproto.uint64_field(203)
    # Error code should be a net::Error value.
    error_code: int = betterproto.int32_field(204)
    # Fields for SUCCESSFUL_CONNECTION messages [300-399]
    time_connection_established_ms: int = betterproto.uint64_field(300)


@dataclass
class LoginRequest(betterproto.Message):
    """*TAG: 2"""

    id: str = betterproto.string_field(1)
    # string. mcs.android.com.
    domain: str = betterproto.string_field(2)
    # Decimal android ID
    user: str = betterproto.string_field(3)
    resource: str = betterproto.string_field(4)
    # Secret
    auth_token: str = betterproto.string_field(5)
    # Format is: android-HEX_DEVICE_ID The user is the decimal value.
    device_id: str = betterproto.string_field(6)
    # RMQ1 - no longer used
    last_rmq_id: int = betterproto.int64_field(7)
    setting: List["Setting"] = betterproto.message_field(8)
    # optional int32 compress = 9;
    received_persistent_id: List[str] = betterproto.string_field(10)
    adaptive_heartbeat: bool = betterproto.bool_field(12)
    heartbeat_stat: "HeartbeatStat" = betterproto.message_field(13)
    # Must be true.
    use_rmq2: bool = betterproto.bool_field(14)
    account_id: int = betterproto.int64_field(15)
    # ANDROID_ID = 2
    auth_service: "LoginRequestAuthService" = betterproto.enum_field(16)
    network_type: int = betterproto.int32_field(17)
    status: int = betterproto.int64_field(18)
    # Events recorded on the client after the last successful connection.
    client_event: List["ClientEvent"] = betterproto.message_field(22)


@dataclass
class LoginResponse(betterproto.Message):
    """* TAG: 3"""

    id: str = betterproto.string_field(1)
    # Not used.
    jid: str = betterproto.string_field(2)
    # Null if login was ok.
    error: "ErrorInfo" = betterproto.message_field(3)
    setting: List["Setting"] = betterproto.message_field(4)
    stream_id: int = betterproto.int32_field(5)
    # Should be "1"
    last_stream_id_received: int = betterproto.int32_field(6)
    heartbeat_config: "HeartbeatConfig" = betterproto.message_field(7)
    # used by the client to synchronize with the server timestamp.
    server_timestamp: int = betterproto.int64_field(8)


@dataclass
class StreamErrorStanza(betterproto.Message):
    type: str = betterproto.string_field(1)
    text: str = betterproto.string_field(2)


@dataclass
class Close(betterproto.Message):
    """* TAG: 4"""

    pass


@dataclass
class Extension(betterproto.Message):
    # 12: SelectiveAck 13: StreamAck
    id: int = betterproto.int32_field(1)
    data: bytes = betterproto.bytes_field(2)


@dataclass
class IqStanza(betterproto.Message):
    """
    * TAG: 7 IqRequest must contain a single extension.  IqResponse may contain
    0 or 1 extensions.
    """

    rmq_id: int = betterproto.int64_field(1)
    type: "IqStanzaIqType" = betterproto.enum_field(2)
    id: str = betterproto.string_field(3)
    from_: str = betterproto.string_field(4)
    to: str = betterproto.string_field(5)
    error: "ErrorInfo" = betterproto.message_field(6)
    # Only field used in the 38+ protocol (besides common
    # last_stream_id_received, status, rmq_id)
    extension: "Extension" = betterproto.message_field(7)
    persistent_id: str = betterproto.string_field(8)
    stream_id: int = betterproto.int32_field(9)
    last_stream_id_received: int = betterproto.int32_field(10)
    account_id: int = betterproto.int64_field(11)
    status: int = betterproto.int64_field(12)


@dataclass
class AppData(betterproto.Message):
    key: str = betterproto.string_field(1)
    value: str = betterproto.string_field(2)


@dataclass
class DataMessageStanza(betterproto.Message):
    """* TAG: 8"""

    # This is the message ID, set by client, DMP.9 (message_id)
    id: str = betterproto.string_field(2)
    # Project ID of the sender, DMP.1
    from_: str = betterproto.string_field(3)
    # Part of DMRequest - also the key in DataMessageProto.
    to: str = betterproto.string_field(4)
    # Package name. DMP.2
    category: str = betterproto.string_field(5)
    # The collapsed key, DMP.3
    token: str = betterproto.string_field(6)
    # User data + GOOGLE. prefixed special entries, DMP.4
    app_data: List["AppData"] = betterproto.message_field(7)
    # Not used.
    from_trusted_server: bool = betterproto.bool_field(8)
    # Part of the ACK protocol, returned in DataMessageResponse on server side.
    # It's part of the key of DMP.
    persistent_id: str = betterproto.string_field(9)
    # In-stream ack. Increments on each message sent - a bit redundant Not used
    # in DMP/DMR.
    stream_id: int = betterproto.int32_field(10)
    last_stream_id_received: int = betterproto.int32_field(11)
    # Sent by the device shortly after registration.
    reg_id: str = betterproto.string_field(13)
    # serial number of the target user, DMP.8 It is the 'serial number' according
    # to user manager.
    device_user_id: int = betterproto.int64_field(16)
    # Time to live, in seconds.
    ttl: int = betterproto.int32_field(17)
    # Timestamp ( according to client ) when message was sent by app, in seconds
    sent: int = betterproto.int64_field(18)
    # How long has the message been queued before the flush, in seconds. This is
    # needed to account for the time difference between server and client: server
    # should adjust 'sent' based on its 'receive' time.
    queued: int = betterproto.int32_field(19)
    status: int = betterproto.int64_field(20)
    # Optional field containing the binary payload of the message.
    raw_data: bytes = betterproto.bytes_field(21)
    # If set the server requests immediate ack. Used for important messages and
    # for testing.
    immediate_ack: bool = betterproto.bool_field(24)


@dataclass
class StreamAck(betterproto.Message):
    """
    *Included in IQ with ID 13, sent from client or server after 10
    unconfirmedmessages.
    """

    pass


@dataclass
class SelectiveAck(betterproto.Message):
    """*Included in IQ sent after LoginResponse from server with ID 12."""

    id: List[str] = betterproto.string_field(1)
